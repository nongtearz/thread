## Info
นายจารุกิตต์ บุญคง รหัสนักศึกษา 6710110548

# Python Threading: CPU-bound vs I/O-bound Tasks

โปรเจกต์นี้เป็นการทดลองเขียนโปรแกรมขนาดเล็กโดยใช้ **Python Threading** เพื่อทำความเข้าใจการทำงานของการประมวลผลแบบ concurrent โดยเปรียบเทียบระหว่างงานที่ใช้ CPU เป็นหลัก (CPU-bound) และงานที่เกี่ยวกับ I/O (I/O-bound) ซึ่งได้รับผลกระทบจาก Global Interpreter Lock (GIL) ใน Python แตกต่างกัน

## โครงสร้างโปรเจกต์
- **`tasks.py`**: ไฟล์นี้กำหนดฟังก์ชัน 2 ตัวที่ใช้ทดสอบ
  - `cpu_heavy_task(task_id)`: งานที่ใช้ CPU หนัก โดยคำนวณผลรวมของเลขยกกำลังสองในลูป 10 ล้านรอบ เพื่อจำลองงานที่ใช้เวลาประมวลผลประมาณ 1 วินาทีต่อทาสก์
  - `io_bound_task(task_id)`: งานที่เกี่ยวข้องกับ I/O โดยจำลองการเขียนและอ่านไฟล์ขนาดใหญ่ (10,000 บรรทัด) และลบไฟล์เมื่อเสร็จสิ้น
- **`thread.py`**: ไฟล์หลักที่ใช้โมดูล `threading` เพื่อรันงานทั้งสองประเภทและวัดเวลาที่ใช้ในการทำงาน

## คำอธิบายโค้ด

### 1. `tasks.py`
ไฟล์นี้กำหนดฟังก์ชัน 2 ตัวสำหรับทดสอบ:
- **`cpu_heavy_task(task_id)`**:
  - เป็นงาน CPU-bound ที่ได้รับผลกระทบจาก GIL
  - ทำการคำนวณ `result += i ** 2` ในลูป 10 ล้านรอบ
  - พิมพ์ข้อความเริ่มต้นและสิ้นสุด พร้อมผลลัพธ์ที่คำนวณได้
- **`io_bound_task(task_id)`**:
  - เป็นงาน I/O-bound ที่ไม่ได้รับผลกระทบจาก GIL มากนัก
  - จำลองการเขียนไฟล์ 10,000 บรรทัด และอ่านกลับมา
  - ลบไฟล์ชั่วคราวหลังจากเสร็จสิ้น
  - พิมพ์ข้อความเริ่มต้นและสิ้นสุด

### 2. `thread.py`
ไฟล์นี้ใช้ `threading` เพื่อรันงานทั้งสองประเภท:
- **`run_tasks(task_func, num_tasks, task_type)`**:
  - ฟังก์ชันที่สร้างและรันเธรดจำนวน `num_tasks` เธรด โดยแต่ละเธรดเรียกใช้ `task_func` (เช่น `cpu_heavy_task` หรือ `io_bound_task`)
  - วัดเวลาทั้งหมดที่ใช้ในการรันงานและพิมพ์ผลลัพธ์
- **`main()`**:
  - รันงานทั้งหมด 4 งานสำหรับ CPU-bound และ I/O-bound
  - พิมพ์ผลลัพธ์เปรียบเทียบเวลา

## วิธีรันโปรแกรม
1. ตรวจสอบว่าไฟล์ `tasks.py` และ `thread.py` อยู่ในโฟลเดอร์เดียวกัน
2. รันคำสั่ง:
   ```bash
   python thread.py
3. ดูผลลัพธ์ในคอนโซล ซึ่งจะแสดงเวลาและการทำงานของแต่ละทาสก์

## ผลลัพธ์
CPU-bound tasks: เนื่องจาก GIL ใน Python ทำให้เธรดไม่สามารถรันพร้อมกันได้อย่างเต็มที่บนหลายคอร์ เวลาที่ใช้จะใกล้เคียงกับการรันแบบลำดับ (sequential) เช่น ถ้า 1 ทาสก์ใช้ 1 วินาที 4 ทาสก์อาจใช้เกือบ 4 วินาที

I/O-bound tasks: เธรดสามารถทำงานพร้อมกันได้ดีขึ้น เพราะ GIL ไม่มีผลมากนักในงาน I/O เวลาที่ใช้จะน้อยกว่าการรันแบบลำดับ

## หมายเหตุ
โปรเจกต์นี้เลือกใช้ threading เพื่อทดสอบความแตกต่างระหว่าง CPU-bound และ I/O-bound tasks ใน Python โดยเฉพาะผลกระทบของ GIL ซึ่งเป็นจุดเด่นที่ทำให้ threading เหมาะกับงาน I/O มากกว่างาน CPU (เมื่อเทียบกับ multiprocessing หรือ asyncio)

หากต้องการประสิทธิภาพสูงสุดสำหรับ CPU-bound tasks ควรใช้ multiprocessing แทน threading